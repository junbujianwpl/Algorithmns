
1. 最短路径
	1. dijkstra算法
		1. 求从起点到图中所有结点的最短路径。还是类似于打表法。因为用到了邻接矩阵。 时间复杂度o(n^2)。
		2. foyd算法map[i,j]=min{map[i,k]+map[k,j],map[i,j]}。三重循环，o(n^3)。
		3. map[n,n]=0.时间复杂度o(n^3)。
		4. 路中不能存在负权值。dijkstra算法中。
	2. Bellman-ford算法
	
2. 最小生成树
	1. 概念，n-1条边将所有n个结点组成图，图连通，且权值和最小。
	1. prim
		1. 以一个结点作为初始结点，迭代找出权重最小的边将点加入其中，路过造成回路的边。
		2. 权值最小的边一定存在于最小生成树中。反证法。
		3. 本质是贪心算法。kruskal也是贪心算法。
		4. 时间复杂度o(n^2)
		
	
	2. kruskal
		1. 边按权重排序。
		2. 从小往大取，有环则跳过。
		3. 并查集。 
		
	3. 最小生成树例题
		1. n台电脑[0,n-1]，可两两相连，相连的代价是c(i,j)，有些电脑之间不能相连，求出一种所有电脑都在网络中的连法。如果有相同的，按字典序取小者。
			1. 给出邻接矩阵，求最小生成树。如果最小生成树有多个，输出字典序最小的那个。
			
	4. 拓扑排序
		1. 对有向无环图，所有顶点排成序列后，若有从u->v的边，则u在序列中出现在v的前面。
		2. 结果不唯一。
		3. 算法。从入度为0的点，输出全部，并将所影响的结点的入度更新。
		4. 拓扑排序的几何意义。


1. 图的表述与搜索
	1. 图的表示
		1. 邻接矩阵
		2. 邻接表
	2. 最小生成树
		1. prim
		2. knu
	2. 搜索
		1. BFS(Breadth-First-Search)，广度(宽度)优先
			1. 最简单、直接的图搜索算法
				1. BFS分析
					1. 第一层是离起点距离为1的
					2. 第二层是离起点距离为2的
					3. 队列，先进先出。给定起点a，将a放入缓冲区，开始搜索。
						1. 假定某时刻缓冲区内为abc，则访问a的邻接点a1a2ax，同时缓冲区变为bca1a2ax，为下一次访问做准备。
						2. 只有队首元素可见，队尾入队，队首出队。
					4. 结点判重
						1. 第一次访问该结点时，是访问次数最少的，最短路径。
						2. 路径记录还是不记录。
							1. 任何结点只有一个前驱，可以有多个后续。pre[]数组存储前驱。
					5. 双向BFS
						1. 形成纺缍形结构。速度更快。降低树的宽度、高度。
				
				2. 应用
					1. Word ladder
						1. 起点，终点，字典，起点通过字典变成终点单词。能否从起点到终点，最短多少步。
						2. 算法：
							1. 建图，
								1. 预处理(每个单词建立map、hash、trie树)
								2. 对于每个单词，变换各位，如果在字典中，则添加到图数据结构中。
							2. 广度优先搜索，看能否到达终点。
					2. 周围区域问题
						1. 问题描述，二维平面，格点处为X或者为O，求出所有由X围成的区域。
							> XXXX
							> XOOX
							> XXXX
						2. 算法
							1. 思路，反向思维。从边界向中心遍历，以边界上的O为起点进行BFS，
							2. 直接碰到的O均标记为其他字符Y。
							3. 遍历所有结节，将O变为X，将Y变为O。即为最终的面积区域。
						3. 应用
							1. java内存回收。从一个地址到另一个地址。
						4. 拓展
							1. 到三维呢。
							
		2. DFS(Depth-First-Search)。深度优先
			1. 理念，不断深入，走到头回退
				1. 一般暴力枚举都是DFS。如N-sum问题解法。
				2. 实现，一般用堆栈，或者递归。
				3. 用途，能获得信息，时间戳，颜色，父子关系，高度等。
				
			2. 类似题
				1. 给定数字字符串，给出所有有效ip地址组合。分割4段。
				2. 八皇后问题
					1. 8X8格上放8皇后，使其不能相互攻击，即不能同行、同列、斜线。
					2. 表示。a[8]。a[i]=k,表示第i行皇后放在k列。
					3. 对1-8字符串进行全排列。并判断是否能相互攻击，需要两两判断一下。
					4. 此外，用深度优先算法。
				3. LCA targan算法

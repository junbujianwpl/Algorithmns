1. simHash计算文章相似度
	1. 分词，给词权重
	2. 各个词hash
	3. 计算权重
	4. 累加和求全文hash签名
	5. 降维，大于0为1，小于0为0
	
	* 海明距离
		> 2个数字异或后1的个数即为海明距离
		
	* 抽屉原理
		> 应用 (x,y)为整数的点为格点。5个格点连线至少有一条连线中点也是格点。
	
	* 倒排索引应用
		> 跳跃链表、跳跃表、跳表。
		> GIS中POI(Point of Interest)查询
		> 部分匹配，跳跃匹配
		
		哈希表，每个结点对应一个平衡二叉树。
		1000万个汉字，取出10000个常用汉字作为哈希索引，一个槽位对应1000个信息，1000个信息用平衡二叉树，哈希o(1)，
		平衡二叉树log1000=9.96。即1000万里找一个东西10次即可。
		思路即为用平衡二叉树来处理哈希冲突，而不是直接拉链。
	
2. 排序
	1. 分类
		1. 内排序
		2. 外排序
	2. 常见方法
		1. 插入/希尔排序
		2. 选择排序/锦标赛排序(nlogn)/堆排序
			1. 锦标赛排序
			2. 堆排序
				1. 完全二叉树。层序遍历不轮空，直到最后一个节点。
				2. 所有节点均大于其孩节点。
				3. 找父节点。(k+1)/2-1。能统一公式。
				4. n中找top m。建立最小堆，长度为m，遍历每个元素，nlogm。
				5. n中找k大的数。
				6. k叉堆结论。建堆(k/(k-1)*n)，调整m*k*plogk((k-1)n]
				7. 一个堆，可以一次输出2个元素，但是调整堆要麻烦一些。
				8. 稳定堆排序。
					1. 建堆，相等则不调整
					2. 调整时，与根相等，与左右孩子不相等，则调整到孩子 
					3. 如果与根左孩子相等，与右孩子不相等，调整到左孩子这一支。递归参考2.
					4. 根右等，对称3.
					
					> 任何一个非稳定的排序算法，将value值与index值共同排序，即可得到稳定的排序算法。
				
		3. 冒泡/快速
			1. 快速排序
				1. 基于划分的排序方法。
				2. 链表来快排，小的放一条链表，大的放另一条链表，递归下去，最后拼接起来。
				3. 快排与归并联系
					1. 都是划分，基于分治的思想。
					2. 快速排序比归并少了一步merge，比归并排序更快。因为哨兵的位置每次都确定了。
						1. T(n)=T(n/2)+cn。
					3. 快速排序最差的复杂度是O(n*n)，2个子数组长度为1和n-1，T(n)=T(1)+T(n-1)+cn。平均是nlogn。
				4. 快速排序与堆排序
					1. 直接竞争者是堆排序。堆排序通常稍慢，但是最坏情况是nlogn。
					2. qsort源码，长则快排，少则插入排序。
					3. 找最k大的数。随机选数，一次划分，数字出现在m位，判断m是否等于k-1。平均时间复杂度为n。最差为n*n。可用二次取中方法使最差为n。
						1. 分成m个小集合，每个小集合找中值，取出中值集合，再划分。
						2. 数组中M出现次数很多，而M恰好选择为pivot。将导致partition之后一部分很长，一部分很短。
						3. 考虑相等元素的O(n)时间选择第k大元素算法。
		4. 归并(nlogn)
			> 基于关键字比较的算法时间复杂度下限就是nlogn
			> 非常方便于外排序。100M内存排序900M数据。各排100M个有序文件，9个排好序的文件进行9路归并排序。
		
		5. 希尔排序
			1. $O(n^1.25)$
			2. 不是基本的排序，是多个排序算法综合的情况。基数排序、桶排序也属于综合性排序。
			
		5. 基数排序
			1. 分关键字分为不同块，每个块进行排序。
			2. 桶排序。

		6. 计数排序
		    1. 空间换时间。
		    2. 一个桶里只放一个数，就是计数排序。
		    3. 一个大hash表，遍历每个元素，在hash表中标记，然后遍历hash表，将标记的元素取出，即为排序后的数组。
		    4. 如果将若干个元素放一个key，就是桶排序了。

	3. 排序的目的是方便查找

		